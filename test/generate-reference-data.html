<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Generate AnalyserNode Reference Data</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			max-width: 800px;
			margin: 50px auto;
			padding: 20px;
		}
		button {
			padding: 10px 20px;
			font-size: 16px;
			margin: 10px 5px;
			cursor: pointer;
		}
		#status {
			margin-top: 20px;
			padding: 10px;
			background: #f0f0f0;
			border-radius: 4px;
		}
		.data-output {
			margin-top: 20px;
			padding: 10px;
			background: #fff;
			border: 1px solid #ccc;
			max-height: 400px;
			overflow-y: auto;
		}
		pre {
			margin: 0;
			white-space: pre-wrap;
		}
	</style>
</head>
<body>
	<h1>Generate AnalyserNode Reference Data</h1>
	<p>This page generates reference FFT data from Chrome's Web Audio API implementation.</p>

	<div>
		<label for="audioFile">Select audio file:</label>
		<input type="file" id="audioFile" accept="audio/*">
	</div>

	<button id="generateBtn" disabled>Generate Reference Data</button>
	<button id="downloadBtn" disabled>Download All JSON Files</button>

	<div id="status"></div>
	<div class="data-output">
		<h3>Generated Data Preview:</h3>
		<pre id="dataPreview"></pre>
	</div>

	<script>
		const audioFileInput = document.getElementById('audioFile');
		const generateBtn = document.getElementById('generateBtn');
		const downloadBtn = document.getElementById('downloadBtn');
		const status = document.getElementById('status');
		const dataPreview = document.getElementById('dataPreview');

		let audioContext;
		let generatedData = {};

		audioFileInput.addEventListener('change', (e) => {
			if (e.target.files.length > 0) {
				generateBtn.disabled = false;
				status.textContent = 'File selected: ' + e.target.files[0].name;
			}
		});

		generateBtn.addEventListener('click', async () => {
			const file = audioFileInput.files[0];
			if (!file) return;

			generateBtn.disabled = true;
			status.textContent = 'Processing...';

			try {
				await generateReferenceData(file);
				status.textContent = 'Reference data generated successfully!';
				downloadBtn.disabled = false;
			} catch (error) {
				status.textContent = 'Error: ' + error.message;
				console.error(error);
			} finally {
				generateBtn.disabled = false;
			}
		});

		downloadBtn.addEventListener('click', () => {
			downloadAllData();
		});

		async function generateReferenceData(file) {
			// Load and decode audio file first
			audioContext = new (window.AudioContext || window.webkitAudioContext)();
			const arrayBuffer = await file.arrayBuffer();
			const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

			status.textContent = `Audio loaded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} channels`;

			// Test different FFT sizes
			const fftSizes = [256, 512, 1024, 2048];
			generatedData = {
				metadata: {
					duration: audioBuffer.duration,
					sampleRate: audioBuffer.sampleRate,
					numberOfChannels: audioBuffer.numberOfChannels,
					generatedBy: 'Chrome ' + navigator.userAgent.match(/Chrome\/(\d+)/)?.[1],
					generatedAt: new Date().toISOString()
				},
				tests: {}
			};

			for (const fftSize of fftSizes) {
				// Use OfflineAudioContext for deterministic results
				const offlineCtx = new OfflineAudioContext(
					audioBuffer.numberOfChannels,
					audioBuffer.sampleRate * 3, // 3 seconds
					audioBuffer.sampleRate
				);

				const source = offlineCtx.createBufferSource();
				source.buffer = audioBuffer;

				const analyser = offlineCtx.createAnalyser();
				analyser.fftSize = fftSize;
				analyser.smoothingTimeConstant = 0; // No smoothing for deterministic results

				source.connect(analyser);
				analyser.connect(offlineCtx.destination);

				source.start(0);

				// Render the audio
				const renderedBuffer = await offlineCtx.startRendering();

				// Now capture data from the analyser (it will have processed all the audio)
				const frequencyBinCount = analyser.frequencyBinCount;

				const floatFreqData = new Float32Array(frequencyBinCount);
				const byteFreqData = new Uint8Array(frequencyBinCount);
				const floatTimeData = new Float32Array(fftSize);
				const byteTimeData = new Uint8Array(fftSize);

				analyser.getFloatFrequencyData(floatFreqData);
				analyser.getByteFrequencyData(byteFreqData);
				analyser.getFloatTimeDomainData(floatTimeData);
				analyser.getByteTimeDomainData(byteTimeData);

				generatedData.tests[`fftSize_${fftSize}`] = {
					fftSize,
					frequencyBinCount,
					minDecibels: analyser.minDecibels,
					maxDecibels: analyser.maxDecibels,
					smoothingTimeConstant: analyser.smoothingTimeConstant,
					floatFrequencyData: Array.from(floatFreqData),
					byteFrequencyData: Array.from(byteFreqData),
					floatTimeDomainData: Array.from(floatTimeData),
					byteTimeDomainData: Array.from(byteTimeData)
				};

				status.textContent = `Processed FFT size ${fftSize}...`;
			}

			// Show preview
			const preview = JSON.stringify(generatedData, null, 2);
			dataPreview.textContent = preview.substring(0, 2000) + '\n\n... (truncated, total ' + preview.length + ' chars)';
		}

		function downloadAllData() {
			// Download as single JSON file
			const dataStr = JSON.stringify(generatedData, null, 2);
			const blob = new Blob([dataStr], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = 'analyser-reference-data.json';
			a.click();
			URL.revokeObjectURL(url);

			status.textContent = 'Downloaded: analyser-reference-data.json';
		}
	</script>
</body>
</html>
